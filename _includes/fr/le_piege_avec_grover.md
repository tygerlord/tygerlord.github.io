# Le piège avec Grover

Lors de mes déambulations sur le net, je suis tombé sur le blog de 'Balise' décrivant [le problème SAT](https://blog.pasithee.fr/2013/02/25/le-probleme-sat/) et comme je trifouillais également dans le quantique à ce moment là, je me suis mis en tête de résoudre l'exemple donné dans le blog de Balise par une méthode quantique.  

<br>

J'ai donc commencé par reproduire la fonction d'exemple composée de portes logiques avec des portes quantiques, j'ai mis au four (200°C, 1ms) et impécablement reproduit la table de vérité attendue. Bien sûre, aucune accélération quantique avec ce procédé. J'ai donc voulu aller plus loin, et toucher du doigt cette puissance de calcul miraculeuse promise en utilisant l'algorithme de [Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm), Et là patatrac, je suis tombé sur un os, ça ne marchait pas. Evidemment je ne pouvais qu'avoir fait une erreur dans mon implémentation, je refuse de croire que cette puissance de calcul comporte un hic, le graal ne peut pas avoir un petit défaut. J'ai donc torturé les circuits dans tous les sens, rien à faire.  

<br>

C'est le coeur lourd que je me suis résolu à me dire que l'algorithme Grover ne fonctionnait pas dans ce cas, ce qui remettait en question son usage, en effet difficile d'imaginer utiliser un algorithme qui peut vous dire qu'il n'y à pas de solutions alors qu'au contraire le problème en comporte plusieurs. 
Heureusement après réflexion, j'ai constaté qu'il y avait des moyens simples de contourner le problème et ainsi d'avoir la certitude d'un fonctionnement correcte dans tous les cas.  

<br>

Avant de détailler ma mésaventure, je vous conseille pour ceux qui veulent aborder ce monde plein de promesses de la quantique d'aller visiter [Quantum : Un peu de mathématiques pour l’informatique quantique](https://exo7math.github.io/quantum-exo7/), formidable resource sur le sujet ainsi que l'excellent blog de [Vivien Londe](https://vivienlonde.github.io/blog) et bien sur l'outils [Qiskit](https://qiskit.org/textbook/ch-algorithms/grover.html)

<br>

Passons au détail que vous pouvez retrouver en intégralité sur [github](https://github.com/tygerlord/le-probleme-sat/blob/main/le_piege_avec_grover.ipynb)




```python
!pip install qiskit
!pip install pylatexenc
```


```python
%matplotlib inline
import qiskit as q

import matplotlib.pyplot as plt

import numpy as np

import math
import operator

```

# Test circuit

# Préparation

Problème a résoudre

![sat-pb.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAASBAMAAABY/C3CAAAAMFBMVEXu7u4zMzPU1NR+fn5wcHCXl5fJycm7u7uJiYni4uJXV1eioqJlZWWwsLBMTEw+Pj6dPk0PAAADQ0lEQVRIDXVVS2gUQRAtZya7M5lMIoKeB4KgKLqKJHgIjKiHIMJe/CAEFiQhGNA16kUvQwRZBGHjJ0Ev2Zt6W9AcPATm7mU1CEqMxqsghODFm69qft1Jp6CrX1W9edPTXb1LtNOq4c6clvG1yETvaoxZLTIEOj0nHMzBbrNVVysmupbT6eqjOdboeZJqBdoNzKkFE90NFYatYDNkunXi/KUzDaVe1b5WKZRwuIQEel+rFZcZjix1cfeIrrZaJWEnEvptIret1Ow8cJHkkVqMiQfbgHhHvJmeSC0Sf1o8XJwNiTX1BKnHRFrjDQoNjt/wPA8Ial6URXaDwfcuezN9hEvBR/a0IR5OldDVmf6GQitn8nw0D6yY6HIe0CGivkYW+XUGScLeTF/m0oDsm5UwZlMlSFMH3TuwrTGv40NWZ0bxXIR3YVqrex0inILIHnu7SEEN6Up8BZ7M9FUuTfc14Ssgr4+8A8wkgmV6hXyUqlu/XzYJ9Or+a6xK59i6AMj17OgR0APye9CZ2vAj8Lq0ghx9mOlRFTE5bTk0M/0uU8flILHogE65jUJi6ia9RzVVJ38BsqDbiYWXKQbhsL/JiQHZAcuNHV5fIpuDdUEwQvyM7BCTmc7r8Gp0EhPWYdFrgFwibNEFBKk6QEPWMVi32ghKY4k9Evo9XDmioXAoxLSSXmgPOIgRz5FcNzP9Kwj4VeALLoveC1BIbNEWgkydngKDPt/ADCvOhRvvPoWci8bZH6dbPDmOrPcwStKnETYeaTOd+xTtwI9wn1Y7chVSCWuzsolypm61UQL9E6dU66dKfJZ6nHpSY3+DHvLk4gRwKhMLdbKbuDwYvF1mOrc52li2sEPTTi3ghzOJjiu6qfrkt0miUXrxiztSNaddHR1ek8x8yJO9/ocnbx/7xeBvenH48vAw0xNU8jFOd2bHukhkEjT2o8eRqHvNn1FK5ZRqgTwiGdlMPL4pUViw+Ni5xsNIl84JUeWRfhNAGmJakiBTB9b+BqTGLiqQAO+fI8tXsnMKNtLRoqWhTzRbal/UYunobRkOZ7blJuT3Skla5Y7tQj+isKmi0dFZX5pqGVijF7UgLKAZ+FraRNff/FnjG4Iu/QdhYr2M8dILFgAAAABJRU5ErkJggg==)

réécriture de F ( je n'ai pas trouvé le OU )

![image.png](data:image/png;base64,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)


# Construction du circuit




```python


def test():
    circuit = q.QuantumCircuit(10, 4)

    circuit.barrier()
    circuit.h([0,1,2])
    
    circuit.barrier()
    circuit.cx([0,1,2], [3,4,5])

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.mct([3,4,5],6)
    circuit.mct([0,1],7)
    circuit.mct([0,4,5],8)

    circuit.barrier()
    circuit.x([6,7,8])

    circuit.barrier()
    circuit.mct([6,7,8],9)

    circuit.barrier()
    m = range(0,3)
    circuit.measure(m,m)
    circuit.measure(9,3)
    return circuit

circuit = test()
```

#  Affichage du circuit


```python
#print(circuit.draw(output='text'))
style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_9_0.png)



# Exécution, Résultats et visualisation

Table de vérité de F, résultat attendu.

![sat-sol.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATAAAAC7BAMAAAAQ1d9vAAAAMFBMVEXu7u4zMzOioqKwsLCJiYnU1NTJycni4uJ+fn5wcHBlZWW7u7s+Pj5XV1dMTEyXl5c8GRrQAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAKGklEQVR4Ae1czYtkVxU/U52a7p5q7Q7oyk0xCRgGdQaSEA2Kg5IsBKETsgjEr/gHOCVuEkJI+bVw5ShC3NkgiOCmRwxkI4aIjLu0KxchEHTrohlEAyGJ99zz8c6pe25X96upvNfy3lD1zr3n4/7euR/vnL51B+7t6QV7oNcFpcCRRqSRKCij4nlVhhfbc81cGIB59wQl8tjF7//q3z/bh9RlxoHG545sRDaTQfzQNUs3/NBlVE7H8MaAu/LZGWwl/TMCu5Qw4Ieug3TDD10Z2NUPPkilA/5QKWBkDW9MgL0PMErsMwLbPQS4ka3i17sAF4+1ZDx2OoY3JsB+C7CRbBKw0UNPPp4LAJPL8CKT8OLfF0U2bwK8nNi/n24eATwPsD1LJZFL5H2P3f8tZVhbAUOMbb41u5ZUuStfh2kqMLBHtm7+OhcAnvkGPMokPP7O9UWRH8N4DjB+5e2NA4CtfXg6CahcetbZTy6lRphhbIUMMgb33PgRWiFg449jAwLsEK1hAeDwHfgpk7C/sZ/JPawnkafhnlQ32Z1vHSd8c3gssVQuMQAfUBjGVsggYzCGh1GJgI3e+Mp1LPEY25lRIX3/Dt7M9ViRFZzI9mwbGZcOP3KYbi/DTSyJHJK38UsY1lbAYGOQn5+Bbd8co2UB9jWkUyFde3kByeSI4e5hPYlMjtPARsks8Cccv2kWsVwix69hBTDD2IoYbAw+mXXIYzvTzVxid1wBbAEbu/j25IhJmKZ/ip1E4OAgVcF34I94u0RLh8ilmtHBpGFYWxGDjY3y+sAe++4+6nOrGwe/3LyWC+mRj7avM7l75cbxogh8bpqq4OvwC7xt/By/VQ7g0e359xqGsRUy2Nid3+Dax8A+j2S6sscmX37uQSqk7x98RjC+MPprIcLL69blfyKLlleVA/jDIz9EbVl3G1shg4xtHn5qjiq5K1/613+Q1n6SAt538CsPISQWRKgqfb+mlBBGRaoKW56hpUzQGJM6HmNURNM7swewYFpxIiQIt0dzppqbUeHK0pZnNLpILQH2zc0jlDKtBMDGx/h2WLiMCnNKW57hDSwBNvriDOVNKwEwuO+/3uiCCjNLW57hbSwBxsJLgHmTVDIqnl1leLFzA6ynuci9Z4tgvfN9qdpjVYbXPzddudfgNo/mSCPSCBeUUfG8KsOLRR7bvXyMQtnCnasFWQJjBWfZtv/kgWFZBlWPrxi2kAyM2k9YsNU78Cqy0cLudDJfJEtgrJAEm8u0f/HqUVNv10Su/fZ7hi0kAeP2GdhtUkbTKWREHI4sgbGC2Mx3Aww2TgYGX3CaVCBg3D4BG+/BhcPERdNPAHxikSyAiQJZ5O+7A4zbJ2CTPdi5xmhuAfx5kSyAicIagHH7Cuyj0wbNPxbJCFhWWA8wbF+B7UxzASAhfn2RjIBlhSTYXHenK7l9AiZDpndjDP6SAKYLv3b2m1kpZOExUWjcxdpSscKspEbJY2kd+yyaRGC70435IlkCY4Uk2Fz52bg4Omrq6aFNOZGf9sVcknUst8/Adi9fR142fef+giyBsQJK6mWAjb/6sanWB8Ce+tuXGrZQsvLn9hkY84xpR5bAxJi9GxVbzc/rq6ISA2OWi5uNaUcOwIwjB48ZZ1TIxTE2xPwVR2n1osfMlHNTURXcMNTakjDanllleLEBmPpjBY9VkhFKKaKujLIJ2/4KyQirUqtxMsIpRQQsyiYMsBWSEVGlVuNkhFOKCFiUTRhgKyQjoppbrQSK3QOT3AKf2SQjvQAWJSO9ABYlI90D6+0Yk9wCx5hJRrr3WCUZAUopwuUiyCbsctE+GeFGT0xGOKWIgEXZhAG2QjIiqq5VY9qRJgDRF2BJGBXPrDK82BBdqD8Gj6krPFF1TJXh9RfH2JCMeP+UpUWPmbXA+NyRRqS0pzVGResyUWV4sXMFzMb8Euinx5G9iNJjHcT8GuibvYgSWAcxv4YUZi+iBNZBzG+APSF7EZ0BszG/Aabhf5fANOb3wGgvoktgGvN7YLQX0RkwG/MbYN2PMRvzG2Aa/nfmMRvza6Bv9iICYB9+zK+BPq78vBdRAhtifnrPmzDAkaXHfFxQaHu2seUZvnSuoguGbh7NkYPHTN/2OOEdkhHTTyE5zEp1i5nhWhcQkccqyYjkJeVy0W0yonlJCazbZEQjoBJYt8lI98AqyUgvgEXJSC+ARclI98AqyUj3wCrJSA+AmV9DmWREyWC56DQZ0bykBDYkI/RONW9bR5YeC97Bwc/EWMrYivSkLnqJlxaMMRfkipXgblQ8t8rwYgMw9UdLjw0xv3qwQgxjTB3TcozhIsUhfLYguw6pWshyHVsx5o8OUMgRM3cCgkN4BHa6ExArxvzRAQoG5k9AcAiPwE53AmLFmD86QMHA3AkIMMD0L8LmMETZlasBk/gv+cFcNCu5fflJM53hQI/proMh7zYwyTEMqkQSMG4/BEa7DhnYejYgErDyAEUDDBsNgdGuQwZG5Do8NsXW3aUew0ZLYL0dY7rrYH5/dLc9JjmGc5jMSncCgk8k0Dp2mhMQ0REG1JZryY+OogMUDIxPYHBXcgifTcuuQ2pDyNJjK8b80QEKBsaNyhijJzXP7MgSmHjG3o2KrR5OQHhvmNLgMXHGkCW5OXYBhmREhkbtPiQj6pnqOqISmYg8VklGut+AiJORHmxAmJjfJCM9+FOnAWYCxX4BM8lI74BhMpBn0sYRTpfwlRQcjbeTjzTzZAvDnkBd4jFW5VZd+ibJSL881tsxZpKRPniM9hNwlJjj2D3YgIiTkWEDgmZv9K4s57WZ++FywRr2ZlRsdbhceAEqDcDUK1VXqkQmBo+pP1p6bEhG1IMVYhhj6piWYwzzX5uMSAaSqtvvjPD2BmErgUUbKxKP1XZGNAMxmyQud8+NLdkZke2NGrBIXf+iOJmjWhEoaqxjNklKYEs2IGR7owYsUmdgonoSMI0ZzwyMNQkXhelM860eWovqScBuyX8TdWZgrNkGmKguAUZ5SRtgqNkSWFZdAozykjbAULMlsKx6EjDubhaRZugeDBKzKrBmG2CiehIwzUvO7DHWbANMVBlYk4xoBmLykgDYyb+Gku0NQmZcyVCjjRVdx+z/DWWSEc1Ako3WOyOyvVEDFm2s6Mo//N9Q0QIrXWrvQ9ij3ggGv/IMcW48NsT8ptdC8tx0pVnWzSh1pBEJn5UqjYqXqjK8WOSxSswv4X8JLArabfvrjfk1/C+BRUG7AbbmmF/D/xJYFLQbYBK4V/s4iJrOEPO3ByZBVQtgonpSPNYe2C3KFnhwG1fKcK97TFTXBiwH7i08loBl1bUBW2fM374rZaC08JiorsdjEri3ACaqDCyM+TX8D5aLTmN+Df9LYFHQbicfZQs8By2DqiL1IeZnd6Vb6bGGZ6joJc5sY8GRZVcae0oaFa3LRJXhxQZg6o//N4/1NRn5H0HX9sOeMgeYAAAAAElFTkSuQmCC)


```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')

simulator.set_options(method="matrix_product_state")

job = q.execute(circuit, simulator, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'1110': 12, '1101': 16, '1010': 5, '0001': 13, '1100': 12, '0111': 15, '0000': 16, '0011': 11}
    {'1101': 16, '0000': 16, '0111': 15, '0001': 13, '1110': 12, '1100': 12, '0011': 11, '1010': 5}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_11_1.png)



Le 4ième bit indique le résultat de F pour les valeurs des 3 premiers bits

ex)
0101 F=1 pour x=0, y=1, z=0



```
XYZF | XYZ | F
--------------
0101 | 010 | 1
0011 | 001 | 1
1011 | 101 | 1
0111 | 011 | 1
```

On retrouve nos 4 solutions du tableau précédent

Par contre, question performance, tel quel, on n'y gagne rien du tout niveau complexité de l'algorithme, pire, on dégrade puisque expérimentalement il faut au moins 16 boucles alors que, en version classique, il y a 8 combinaisons à tester. 

Il y a une dimension dans notre circuit que nous n'avons pas utilisé, les probabilités.


# Utilisation des propriétés quantiques

Pour aller plus loin il faut réussir à utiliser les propriétés quantiques afin d'orienter la ou les solution(s) vers une plus forte probabilité en utilisant l'algorithme de [Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm). 



# Construction du circuit 2

Utilisation de l'algorithme de Grover. La documentation de [Qiskit](https://qiskit.org/textbook/ch-algorithms/grover.html) fournit un exemple et des explications complètes sur cet algorithme.





```python

def diffuser(nqubits):
    qc = q.QuantumCircuit(nqubits)
    # Apply transformation |s> -> |00..0> (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
    # Apply transformation |00..0> -> |11..1> (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit)
    # Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
    # Apply transformation |11..1> -> |00..0>
    for qubit in range(nqubits):
        qc.x(qubit)
    # Apply transformation |00..0> -> |s>
    for qubit in range(nqubits):
        qc.h(qubit)
    # We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = "U$_s$"
    return U_s

var_qubits = q.QuantumRegister(3, name='v')
clause_qubits = q.QuantumRegister(6, name='c')
output_qubit = q.QuantumRegister(1, name='out')
cbits = q.ClassicalRegister(3, name='cbits')

circuit = q.QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def test2(circuit, var_qubits, clause_qubits, output_bits):

    circuit.cx([0,1,2], [3,4,5])

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.mct([3,4,5],6) 
    circuit.mct([0,1],7)
    circuit.mct([0,4,5],8)

    circuit.barrier()
    circuit.x([6,7,8])

    circuit.mct([6,7,8],9)

    # uncomputation
    circuit.barrier()
    circuit.x([6,7,8])

    circuit.barrier()
    circuit.mct([3,4,5],6) 
    circuit.mct([0,1],7)
    circuit.mct([0,4,5],8)

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.cx([2,1,0], [5,4,3])

 
# Initialize 'out0' in state |->
circuit.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s>
circuit.h([0,1,2])
circuit.barrier()  # for visual separation

## N Iteration
for i in range(0,1):
    # Apply our oracle
    test2(circuit, var_qubits, clause_qubits, output_qubit)
    circuit.barrier()  # for visual separation

    # Apply our diffuser
    circuit.append(diffuser(3), [0,1,2])


# Measure the variable qubits
circuit.measure(var_qubits, cbits)

```




    <qiskit.circuit.instructionset.InstructionSet at 0x7f302d5f2250>



#  Affichage du circuit 2


```python

style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_17_0.png)



# Exécution, Résultats et visualisation 2



```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')
#simulator = q.Aer.get_backend('aer_simulator')#'qasm_simulator')

simulator.set_options(method="matrix_product_state")


job = q.execute(circuit, simulator, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'010': 16, '101': 7, '001': 12, '000': 18, '111': 13, '011': 14, '110': 9, '100': 11}
    {'000': 18, '010': 16, '011': 14, '111': 13, '001': 12, '100': 11, '110': 9, '101': 7}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_19_1.png)



Le résultat est plutôt décevant !  Ces valeurs ne permettent pas de déterminer une solution à notre fonction F alors que nous savons qu'il y en a quatre...

Pour tenter de comprendre ce qui se passe, développons l'algorithme sur 3 fonctions ayant respectivement 3, 4 et 0 solutions.


![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAGACAIAAAD+gYtUAAAAA3NCSVQICAjb4U/gAAAgAElEQVR4Xu2dd7hURba3JUdJggFFkgLmjKgY0dFRR0wwo2Mc0xhGdK55jOOYUUfH+FyzoMI1o2JOg5gRAygZQUSUKEmQ8L139vP107fDPk337j69u9/+g+ec2lWrVr3V7N9eq6r2qbN69eq1/EhAAhKQgASqlUDdah2445aABCQgAQn8LwGF0O+BBCQgAQlUNQGFsKqn38FLQAISkIBC6HdAAhKQgASqmoBCWNXT7+AlIAEJSEAh9DsgAQlIQAJVTUAhrOrpd/ASkIAEJKAQ+h2QgAQkIIGqJqAQVvX0O3gJSEACElAI/Q5IQAISkEBVE1AIq3r6HbwEJCABCSiEfgckIAEJSKCqCSiEVT39Dl4CEpCABBRCvwMSkIAEJFDVBBTCqp5+By8BCUhAAgqh3wEJSEACEqhqAgphVU+/g5eABCQgAYXQ74AEJCABCVQ1AYWwqqffwUtAAhKQgELod0ACEpCABKqagEJY1dPv4CUgAQlIoL4IJCCBaiNw0003TZs2rWSjPuGEE3bYYYeSdWdHElhTAgrhmhKzvgRiT2DjjTdu3LhxyYbRokWLkvVlRxLIg0Cd1atX59HMJhKQgAQkIIHKIOAaYWXMo6NYAwIrVqxYtWrVGjSItCpd40CkJgs1tnz58kJNJLWP1lqEjmlKAtkIKITZyFhemQS++eabq666as6cObU1vMWLF998882ff/55bTmQ3C+q/OSTTz744IMrV66MxB8MPvfcc4899lhUBiPxSiMSCCegEIbz8WpxCfzyyy+33HLL7rvvvvbaa++8884nnXTSySeffPzxx++7775t2rQ57rjjog0vZs2ahQoecsgh7dq1K+7AsltnpEceeeTtt9/+7bffZq9VoitvvfXWiy+++Pvf/75evXqRdFm3bt3f/e53yDxmIzGoEQmUggBrhH4kULsE7rzzzubNm7/22mvJbjzwwANnnnnmr7/+GpVvJCSvuOKK66+/nmClQJtz585dtmxZIUbuu+++Cy64IOPoJk6ciCxl+xByFdJvctvZs2fzTPDBBx9QuGTJkmw9Ur7RRhslN3z99dezVf7LX/5Cza+//vrQQw/9/vvvM7q63XbbZWv+1FNPZWxioQSKSsBdo6V42rCPEALEfNyL27dv37179+RqbLgnXiTCCGm7RpcmTZo0fPjwhx56qECbOHz11VcfccQRu+222xo5kFz5t7/97eOPPz5mzJhtttkmxUjXrl2XLl2azXKdOnWyXVrT8meffbZhw4aBA02aNMm903322SdbZRQONzbZZBM2pg4ZMuScc85J9+qjjz7ippZeTkn9+t6RMoKxsLgEIrvLFNdNrVcugXnz5n355ZdbbLHFuuuuyygJTRILeBtuuGGBopWM7dVXX0Vj+BTOkpiywO02DJYhv/DCCxntNMj+Kdz5wAKchw0bRhozcY4ie58NUvQJMc5WOZgv6u+3336vvPLKggUL0h3marbmEcp8er+WSCAbAZ+/spGxvEQEWCqbOnXqUUcdxc2RLlm14m544IEHbv2fT1ROEMa98847O+20EzFQwiYiRCEyPH/+fNbJiM/YStOyZUvWJlnJK7xr7D/zzDODBw8+/PDDGSAJw0WLFvXq1QvLiAGhGDEZUW/Tpk1T+iKL+/LLL48aNQqxPOyww1AXdOvpp59mMbVjx46FO4aFH374Yfz48SnxKO6x1WXGjBnNmjUja8rPKBmzcNBBB2V8ImFEN954I6J+8cUXY/Pdd9894IADAsKbbbYZXXz33XfwTHeYRUQmmvTyGWecAWpAvf3223Sx1157pVe2RALFJqAQFpuw9msgwO0eMSDG4tY/ffp0VonYSJKtDcEii3zcXrNVIDWHpKXfuBcuXDhlypR+/folNyRkIcXHSuT999/PpYsuuojFsHPPPRd56N27d7Yuci9/8803ycQiXUOHDh09ejQ3+gsvvDDRvHPnzgwEDU4XwmARDjcGDhyIJ+uttx7NL7vsMpKNKUL44Ycf3nPPPQDM5lWrVq3OO++89DiYhw+asCMp0RAjjzzyyJ577knW99hjj2W3y7XXXss7aAhb8aF169YpXaBzV1555TrrrDN58mTQMTp2OSWeM+iXdCtai5anNOTRZ+TIkX379j366KO33Xbb/fff/+eff8YUIrrHHntkVNxso7NcApEQUAgjwaiRPAkQ+rBAyM2Ul4/MnDnziy++4E66wQYbZDNHHo8AZf31189WASHs0KFD+s2UWIccbPIrTtDUsWPHnnbaaTQh3mLfChrA2QY26RA4ZrO/RuWkdh999FEkgd2q/NC/f39GmrDAz8RbKHSKTVwl0iIq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u+66jz/+uBbHOG7cuBtuuGH+/Pm5+PDNN99cddVVc+bMyaVyMepwT3/uuecee+yxlStXFsN+YDPyYdYu5MWLF998882ff/558YhpOb4EFML4zl2xPGeV6Mgjj1xnnXU6dep0zDHHnHzyySeddNJhhx3Gr927d588eXKEHfPUz+1p7bXXJikXodk1NbXFFltssskmeLJs2bLwtrNmzUIFWdwqZQoxxSUi19/97nfc01988cVwb/O+Woxh1i5kvmN8q1kU/Pbbb/PGYsNKJVBryahKBVoB4zrggAM23njjvffeu1+/ftdff329evWCQX399dfnn39+tAnM995774svvnjggQdyT0tmJPzLL7/8+uuv3OwyXs2l8KCDDuIJ4PXXX+eHbPWJwO6+++5tt912hx12oM5PP/0UEpOtt956derUyWiKkG7evHk8amS8GhQSnjKojBVY3GratCnbTC6++OKddtppgw02yFgt78KUYRL7wjabtXXXXTcxd6yzoKAZazZo0IDx5gE5o7X8Crt27brrrruyJeeaa66J9mucnz+2Kh8CCmH5zEUZeYI4LVmypFevXgkVxDl22XEfad68eVSOcqNHV37zm9+0bNmyQJvPP//8pEmTLrzwwrwFFWnp27cvkrznnntmGyNdDB8+/KGHHgp62X///WfMmJHNcypnszN9+nTCSgLQ1q1bZ2s+YMCAbBs4r7jiijPOOIMQlueVIUOGnHPOOdmM5FeeMswjjjiCZ6Bspj777LP27dsHV0k/brPNNhlr8vTwyiuv5AE5o7W8C3/7298+/vjjY8aMyeZn3pZtGGsCCmGsp68ozhMQfPTRR4QdW221FR0QvvCYT3zD8z75wGbNmkXVKzfciRMnskBYuEF8w88C7fTs2RNx4i6ZLU/76quvElXwCToaNWpU3j0COXyf2sMPPxxunJhmv/32u/POOwkNC3+SSO4rZZhvv/12uCeJqwh/togwUWdNIefYdY7ViF/J0L7wwgt8t/N+ZsqxL6vFiIBCGKPJKpGr7F755JNPWA4Mcm7ffffdU089deaZZ5J4POWUUyJ0gg0yrVq14t6UbJPe2QlCpIXishTHzwsWLNh6663JqkVy5yK4ufHGG+mUvCL9vvvuu6SCgx2Ybdq0Qe95CMgohGzUfOedd0hFJm/XRH0p/PLLL8lk/v73v0dE2WOCLB13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m266KaMd3P7Xv/6V8ZKFEqhaAgph1U69A6+ZAGt1H330UYsWLbbaaitqs4Y3a9as9dZbjwRpu3btmjVrVrOJ3GqgtcOGDTv88MPJvubWYq2ePXvefPPNY8aM2XnnnVOa/OE/nxztWE0CEnCzjN8BCWQlsGjRok8++aR79+4bbLABlb777rsnnniCTZssGZ5yyikRrs/98MMP48ePTw4H6eWFF174+9///tRTTwV7RBFLVhC//fbbwN02bdogyeh0Ru/JjrLphkXEsWPHBhWmTJkyePDgX375JWN9CyVQzQSMCKt59h17DQS+//77CRMm7LLLLu++++7ixYvRpP32248EZrZmH3744T333BMiNqz/nXfeeV27dk2xMHXqVErQtkQ5638kY5HGgQMHsk8HzRs9evRll102ZMiQjh07Uo0Vys6dO3/55ZdIZspq5bJly9h9iquffvop6VO2mNapU+eRRx555513Dj744NyDzmzDtFwCFUZAIaywCXU4URJAZn7++Wd2l8yePZtwcPLkyVtvvXVIB+uuu+72228fchCQ9TwSrekWZs6ciZglQkwiUfbjHHfccaggTYIcLKq2zjrrdOrUKWhet27dtm3bfvXVV+RvU4Rw4sSJqB0d0YRtPqjg0qVLP/744+222y59QTHdGUskUG0EFMJqm3HHmyuBYIGQGO7kk0/u1q0bYRaxYEKHMlohRPvLX/6S8VJ4IWlPjCdiTfbCkHql8M033zzqqKNQL8T1gw8+YKkyeU8pwonCpR863HTTTQk6R4wY8eOPP/bp0wfJ5AdC22OPPTZ5y0+4S16VQPUQUAirZ64d6ZoRCBYIkcBggRAJOfLIIwnCQqywmId6pStTokmDBg0QuXQLSCAZzl9//TW4hHQhfu+//z5LfRzeoJDDi8SIp556anJilr6IBdO1jTr48Morr+B8kIZlpZCS8HA23StLJFAlBNwsUyUT7TDXmADpSjawsDkzkK5gTQ6JCjH0zDPPrL/++gRt2T4cwCdFmW6BnGqyEAYVOLbP3tSNNtqIX8nKooXkXRNtEV2kmu7ShZA6RIqjRo3adtttmzRpQk065chH+/bt07u2RAISCPtfLR0JVDMBThAuXLhwxx13zKg0GckcccQRiBOHK7J92B260047pbcl44p0caY+cQn1QhpZFETJCOZ4iw3BaHJilquTJk0i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)

# Construction du circuit (x+z).!y

---






```python

def diffuser(nqubits):
    qc = q.QuantumCircuit(nqubits)
    # Apply transformation |s> -> |00..0> (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
    # Apply transformation |00..0> -> |11..1> (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit)
    # Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
    # Apply transformation |11..1> -> |00..0>
    for qubit in range(nqubits):
        qc.x(qubit)
    # Apply transformation |00..0> -> |s>
    for qubit in range(nqubits):
        qc.h(qubit)
    # We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = "U$_s$"
    return U_s

var_qubits = q.QuantumRegister(3, name='v')
clause_qubits = q.QuantumRegister(5, name='c')
output_qubit = q.QuantumRegister(1, name='out')
cbits = q.ClassicalRegister(3, name='cbits')

circuit = q.QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def test2(circuit, var_qubits, clause_qubits, output_bits):

    circuit.cx([0,1,2], [3,4,5])

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.mct([3,5],6) 
    circuit.mct([1],7)
 
    circuit.barrier()
    circuit.x([6,7])

    circuit.mct([6,7],8)

    # uncomputation
    circuit.barrier()
    circuit.x([6,7])

    circuit.barrier()
    circuit.mct([3,5],6) 
    circuit.mct([1],7)

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.cx([2,1,0], [5,4,3])

 
# Initialize 'out0' in state |->
circuit.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s>
circuit.h([0,1,2])
circuit.barrier()  # for visual separation

## N Iteration
for i in range(0,1):
    # Apply our oracle
    test2(circuit, var_qubits, clause_qubits, output_qubit)
    circuit.barrier()  # for visual separation

    # Apply our diffuser
    circuit.append(diffuser(3), [0,1,2])


# Measure the variable qubits
circuit.measure(var_qubits, cbits)

```




    <qiskit.circuit.instructionset.InstructionSet at 0x7f302ce98950>



#  Affichage du circuit (x+z).!y


```python

style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_24_0.png)



# Exécution, Résultats et visualisation (x+z).!y



```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')
#simulator = q.Aer.get_backend('aer_simulator')#'qasm_simulator')

simulator.set_options(method="matrix_product_state")


job = q.execute(circuit, simulator)#, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'010': 35, '100': 286, '110': 33, '001': 288, '101': 285, '000': 41, '111': 26, '011': 30}
    {'001': 288, '100': 286, '101': 285, '000': 41, '010': 35, '110': 33, '011': 30, '111': 26}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_26_1.png)



Le résultat est conforma à nos attentes, on retrouve bien nos 3 solutions !

# Construction du circuit (x+z).(!x+!y)





```python

def diffuser(nqubits):
    qc = q.QuantumCircuit(nqubits)
    # Apply transformation |s> -> |00..0> (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
    # Apply transformation |00..0> -> |11..1> (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit)
    # Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
    # Apply transformation |11..1> -> |00..0>
    for qubit in range(nqubits):
        qc.x(qubit)
    # Apply transformation |00..0> -> |s>
    for qubit in range(nqubits):
        qc.h(qubit)
    # We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = "U$_s$"
    return U_s

var_qubits = q.QuantumRegister(3, name='v')
clause_qubits = q.QuantumRegister(5, name='c')
output_qubit = q.QuantumRegister(1, name='out')
cbits = q.ClassicalRegister(3, name='cbits')

circuit = q.QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def test2(circuit, var_qubits, clause_qubits, output_bits):

    circuit.cx([0,1,2], [3,4,5])

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.mct([3,5],6) 
    circuit.mct([0,1],7)
 
    circuit.barrier()
    circuit.x([6,7])

    circuit.mct([6,7],8)

    # uncomputation
    circuit.barrier()
    circuit.x([6,7])

    circuit.barrier()
    circuit.mct([3,5],6) 
    circuit.mct([0,1],7)

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.cx([2,1,0], [5,4,3])

 
# Initialize 'out0' in state |->
circuit.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s>
circuit.h([0,1,2])
circuit.barrier()  # for visual separation

## N Iteration
for i in range(0,1):
    # Apply our oracle
    test2(circuit, var_qubits, clause_qubits, output_qubit)
    circuit.barrier()  # for visual separation

    # Apply our diffuser
    circuit.append(diffuser(3), [0,1,2])


# Measure the variable qubits
circuit.measure(var_qubits, cbits)

```




    <qiskit.circuit.instructionset.InstructionSet at 0x7f302c983990>



#  Affichage du circuit (x+z).(!x+!y)


```python

style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_31_0.png)



# Exécution, Résultats et visualisation (x+z).(!x+!y)



```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')
#simulator = q.Aer.get_backend('aer_simulator')#'qasm_simulator')

simulator.set_options(method="matrix_product_state")


job = q.execute(circuit, simulator)#, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'110': 120, '100': 139, '010': 122, '101': 130, '001': 124, '011': 123, '000': 151, '111': 115}
    {'000': 151, '100': 139, '101': 130, '001': 124, '011': 123, '010': 122, '110': 120, '111': 115}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_33_1.png)



Là, il se passe quelque chose qui cloche, nous n'obtenons pas nos 4 solutions.

# Construction du circuit (y).!y



```python

def diffuser(nqubits):
    qc = q.QuantumCircuit(nqubits)
    # Apply transformation |s> -> |00..0> (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
    # Apply transformation |00..0> -> |11..1> (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit)
    # Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
    # Apply transformation |11..1> -> |00..0>
    for qubit in range(nqubits):
        qc.x(qubit)
    # Apply transformation |00..0> -> |s>
    for qubit in range(nqubits):
        qc.h(qubit)
    # We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = "U$_s$"
    return U_s

var_qubits = q.QuantumRegister(3, name='v')
clause_qubits = q.QuantumRegister(5, name='c')
output_qubit = q.QuantumRegister(1, name='out')
cbits = q.ClassicalRegister(3, name='cbits')

circuit = q.QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def test2(circuit, var_qubits, clause_qubits, output_bits):

    circuit.cx([0,1,2], [3,4,5])

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.mct([4],6) 
    circuit.mct([1],7)
 
    circuit.barrier()
    circuit.x([6,7])

    circuit.mct([6,7],8)

    # uncomputation
    circuit.barrier()
    circuit.x([6,7])

    circuit.barrier()
    circuit.mct([4],6) 
    circuit.mct([1],7)

    circuit.barrier()
    circuit.x([3,4,5])

    circuit.barrier()
    circuit.cx([2,1,0], [5,4,3])

 
# Initialize 'out0' in state |->
circuit.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s>
circuit.h([0,1,2])
circuit.barrier()  # for visual separation

## N Iteration
for i in range(0,1):
    # Apply our oracle
    test2(circuit, var_qubits, clause_qubits, output_qubit)
    circuit.barrier()  # for visual separation

    # Apply our diffuser
    circuit.append(diffuser(3), [0,1,2])


# Measure the variable qubits
circuit.measure(var_qubits, cbits)

```




    <qiskit.circuit.instructionset.InstructionSet at 0x7f302c4d96d0>



#  Affichage du circuit (y).!y


```python

style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_38_0.png)



# Exécution, Résultats et visualisation (y).!y



```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')
#simulator = q.Aer.get_backend('aer_simulator')#'qasm_simulator')

simulator.set_options(method="matrix_product_state")


job = q.execute(circuit, simulator)#, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'001': 138, '101': 137, '110': 114, '100': 135, '010': 122, '000': 112, '011': 135, '111': 131}
    {'001': 138, '101': 137, '100': 135, '011': 135, '111': 131, '010': 122, '110': 114, '000': 112}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_40_1.png)



Là c'est plutôt conforme à ce qu'on est en droit d'attendre, il n'y a pas de solutions possible.



L'algorithme de Grover ne semble pas fonctionner correctement lorsqu'on a beaucoup de solutions, disons au moins N/2 solutions, on obtient un résultat sensiblement identique à 0 solutions. (Je laisse aux mathématiciens chevronnés le soin de justifier ou non ce comportement de l'algorithme)

Comment éviter cet écueil ?

Si c'est possible, déterminer à l'avance le nombre de solutions et vérifier qu'il soit inférieur à N/2.

Si on ne peut pas déterminer le nombre de solutions, j'ai envisagé 2 possibilités selon les cas d'usages:

1) On peut, si on tombe sur un cas zéro solution, tester aléatoirement quelques solutions, si on est dans un cas de nombreuses solutions on a de bonne chance d'en trouver une. 

2) On peut également ajouter un qubit supplémentaire d'entré et l'intégrer à l'Oracle, ce qui va artificiellement faire monter le nombre de combinaisons et donc faire chuter le nombre de solutions sous (N+1)/2.


# Construction du circuit 3



```python

def diffuser(nqubits):
    qc = q.QuantumCircuit(nqubits)
    # Apply transformation |s> -> |00..0> (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
    # Apply transformation |00..0> -> |11..1> (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit)
    # Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
    # Apply transformation |11..1> -> |00..0>
    for qubit in range(nqubits):
        qc.x(qubit)
    # Apply transformation |00..0> -> |s>
    for qubit in range(nqubits):
        qc.h(qubit)
    # We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = "U$_s$"
    return U_s

var_qubits = q.QuantumRegister(4, name='v')
clause_qubits = q.QuantumRegister(6, name='c')
output_qubit = q.QuantumRegister(1, name='out')
cbits = q.ClassicalRegister(4, name='cbits')

circuit = q.QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def test2(circuit, var_qubits, clause_qubits, output_bits):

    circuit.cx([0,1,2], [4,5,6])

    circuit.barrier()
    circuit.x([4,5,6])

    circuit.barrier()
    circuit.mct([4,5,6],7) 
    circuit.mct([0,1],8)
    circuit.mct([0,5,6],9)

    circuit.barrier()
    circuit.x([7,8,9])

    circuit.mct([3,7,8,9],10)

    # uncomputation
    circuit.barrier()
    circuit.x([7,8,9])

    circuit.barrier()
    circuit.mct([4,5,6],7) 
    circuit.mct([0,1],8)
    circuit.mct([0,5,6],9)

    circuit.barrier()
    circuit.x([4,5,6])

    circuit.barrier()
    circuit.cx([2,1,0], [6,5,4])

 
# Initialize 'out0' in state |->
circuit.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s>
circuit.h([0,1,2,3])
circuit.barrier()  # for visual separation

## N Iteration
for i in range(0,1):
    # Apply our oracle
    test2(circuit, var_qubits, clause_qubits, output_qubit)
    circuit.barrier()  # for visual separation

    # Apply our diffuser
    circuit.append(diffuser(4), [0,1,2,3])


# Measure the variable qubits
circuit.measure(var_qubits, cbits)

```




    <qiskit.circuit.instructionset.InstructionSet at 0x7f302c0150d0>



#  Affichage du circuit 3


```python

style = { "figwidth" : 50 }
circuit.draw(output='mpl', scale=0.5)#style=style)
```




![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_46_0.png)



# Exécution, Résultats et visualisation 3



```python
repeat = 100

simulator = q.Aer.get_backend('qasm_simulator')
#simulator = q.Aer.get_backend('aer_simulator')#'qasm_simulator')

simulator.set_options(method="matrix_product_state")


job = q.execute(circuit, simulator, shots=repeat)

result = job.result()

counts = result.get_counts(circuit)
print("Nombre de '0'et de '1':",counts)

sorted_counts = dict( sorted(counts.items(), key=operator.itemgetter(1), reverse=True))
print(sorted_counts)

q.visualization.plot_histogram(counts)

```

    Nombre de '0'et de '1': {'1110': 27, '1010': 23, '1101': 27, '1100': 23}
    {'1110': 27, '1101': 27, '1010': 23, '1100': 23}





![png](le%20piege%20avec%20grover_files/le%20piege%20avec%20grover_48_1.png)




On retrouve bien le résultat de notre fonction F:


```
XYZF | XYZ | F
--------------
0101 | 010 | 1
0011 | 001 | 1
1011 | 101 | 1
0111 | 011 | 1
```






Malgré cet excellent résultat, il manque une justification mathématique à tout ceci. De plus en théorie il nous faudrait √(N/M) rotations avec 4 qubits N=16 et 4 solutions M=4 cela fait 2 rotations or le résultat est très bon en une rotation. Il faudra donc étudier plus finement ce qui se passe exactement ainsi que l'impact de ce qubit supplémentaire sur les autres cas. 


```python
import qiskit.tools.jupyter
%qiskit_version_table
```


<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.18.3</td></tr><tr><td><code>qiskit-aer</code></td><td>0.9.1</td></tr><tr><td><code>qiskit-ignis</code></td><td>0.6.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.18.0</td></tr><tr><td><code>qiskit-aqua</code></td><td>0.9.5</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.12 (default, Sep 10 2021, 00:21:48) 
[GCC 7.5.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>1</td></tr><tr><td>Memory (Gb)</td><td>12.686656951904297</td></tr><tr><td colspan='2'>Wed Nov 17 19:16:19 2021 UTC</td></tr></table>

